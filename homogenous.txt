'''dtvec = -np.transpose(tvec_n - tvec_m)
    # tvec_mh = np.array([[tvec_m[0][0]], [tvec_m[0][1]], [tvec_m[0][2]], [1]]) # tvec of 'm' marker
    # tvec_nh = np.array([[tvec_n[0][0]], [tvec_n[0][1]], [tvec_n[0][2]], [1]]) # tvec of 'n' marker
    dtvec = tvec_m - tvec_n # vector from 'm' to 'n' marker in the camera's coordinate system
    #print(tvec_nh)
    # get the markers' rotation matrices respectively
    R_m = cv2.Rodrigues(rvec_m)[0]
    R_n = cv2.Rodrigues(rvec_n)[0]
    R_mh = np.array([[R_m[0][0], R_m[0][1], R_m[0][2], 0],
                     [R_m[1][0], R_m[1][1], R_m[1][2], 0],
                     [R_m[2][0], R_m[2][1], R_m[2][2], 0],
                     [    0    ,     0    ,     0    , 1]])
    R_nh = np.array([[R_n[0][0], R_n[0][1], R_n[0][2], 0],
                     [R_n[1][0], R_n[1][1], R_n[1][2], 0],
                     [R_n[2][0], R_n[2][1], R_n[2][2], 0],
                     [    0    ,     0    ,     0    , 1]])
    #print(np.matmul(R_mh, R_mh.T))
    dtvec_m = np.matmul(-R_m.T, dtvec)
    dTh = np.array([[1, 0, 0, dtvec[0][0]],
                    [0, 1, 0, dtvec[1][0]],
                    [0, 0, 1, dtvec[2][0]],
                    [0, 0, 0,       1     ]])
    #print(dTh)

    tvec_mm = np.matmul(-R_m.T, np.transpose(tvec_m)) # camera pose in 'm' marker's coordinate system
    tvec_nn = np.matmul(-R_n.T, np.transpose(tvec_n)) # camera pose in 'n' marker's coordinate system
    tvec_mmh = np.matmul(-R_mh.T, tvec_mh) # camera pose in 'm' marker's coordinate system
    tvec_nnh = np.matmul(-R_nh.T, tvec_nh) # camera pose in 'n' marker's coordinate system
    dM=np.matmul(-R_mh.T, dTh)
    #dM=np.matmul(R_mh, np.matmul(R_nh, dTh))

    # translational difference between markers in 'm' marker's system,
    # basically the origin of 'n'
    #dtvec_m = np.matmul(-R_m.T, dtvec)

    # this gets me the same as tvec_mm,
    # but this only works, if 'm' marker is seen
    tvec_nm1 = dtvec_m + np.matmul(-R_m.T, np.transpose(tvec_n))
    print("nm2")
    print(tvec_nm1)

    # ## identical
    # # something with the rvec difference must give the transformation(???)
    # rvec_mm = np.transpose(np.matmul(-R_m.T, np.transpose(rvec_m)))
    # rvec_nm = np.transpose(np.matmul(-R_m.T, np.transpose(rvec_n)))
    # print(rvec_mm)
    # drvec_mm = rvec_mm - rvec_nm
    # dR_m = cv2.Rodrigues(drvec_mm)[0]
    # # I want to transform tvec_nn with a single matrix,
    # # so it would be interpreted in 'm' marker's system
    # tvec_nm = dtvec_m + np.matmul(dR_m, tvec_nn)
    # ##

    # ## identical
    # drvec = rvec_m - rvec_n
    # drvec_m = np.transpose(np.matmul(R_m.T, np.transpose(drvec)))
    # dR_m = cv2.Rodrigues(drvec_m)[0]
    # tvec_nm2= dtvec_m + np.matmul(dR_m.T, tvec_nn)
    # ##

    print("tvec_mmh:")
    print(tvec_mmh)
    print("tvec_mm:")
    print(tvec_mm)
    # print("dM:")
    # print(dM)
    tvec_nm=np.matmul(dM, tvec_nh)
    print("tvec_nm:")
    print(tvec_nm)
    # objective: tvec_mm == tvec_nm'''